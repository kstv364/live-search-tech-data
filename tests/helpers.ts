import { Page, expect } from '@playwright/test';/** * Utility functions for common test operations */export class TestHelpers {  constructor(private page: Page) {}  async addTechnologyFilter(techName: string): Promise<boolean> {    const selectors = [      `button:has-text("${techName}")`,      `[role="button"]:has-text("${techName}")`,      `button[data-tech="${techName}"]`,      `.tech-button:has-text("${techName}")`,    ];    for (const selector of selectors) {      try {        const button = this.page.locator(selector).first();        await button.waitFor({ state: 'visible', timeout: 2000 });        await button.click();        await this.page.waitForTimeout(2000);        return true;      } catch (error) {        continue;      }    }    return false;  }  async performSearch(): Promise<boolean> {    const searchButton = this.page.getByRole('button', { name: /Search/i });    try {      await searchButton.waitFor({ state: 'visible', timeout: 2000 });      await expect(searchButton).toBeEnabled({ timeout: 10000 });      await searchButton.click();      await this.page.waitForTimeout(2000);      await this.page.waitForTimeout(2000);      return true;    } catch (error) {      return false;    }  }  async hasSearchResults(): Promise<boolean> {    const hasTable = await this.page.getByRole('table').isVisible();    const hasResultsText = await this.page.getByText(/companies found/i).isVisible();    return hasTable || hasResultsText;  }  async getFilterCount(): Promise<number> {    const filterText = await this.page.getByText(/(\d+)\s+filter/).textContent();    if (filterText) {      const match = filterText.match(/(\d+)\s+filter/);      return match ? parseInt(match[1]) : 0;    }    return 0;  }async clearAllFilters() {    const selectors = [      'button:has-text("Clear All")',      'button[data-slot="button"]:has-text("Clear All")',      '[data-slot="button"]:has-text("Clear All")',    ];    for (const selector of selectors) {      try {        const clearButton = this.page.locator(selector).first();        await clearButton.waitFor({ state: 'visible', timeout: 2000 });        await clearButton.click();        await this.page.waitForTimeout(2000);        return;      } catch (error) {        continue;      }    }  }  async showTableFilters() {    const showFiltersButton = this.page.getByRole('button', { name: /Show Filters/i });    if (await showFiltersButton.isVisible()) {      await showFiltersButton.click();    }  }  async hideTableFilters() {    const hideFiltersButton = this.page.getByRole('button', { name: /Hide Filters/i });    if (await hideFiltersButton.isVisible()) {      await hideFiltersButton.click();    }  }  async sortTableColumn(columnName: string) {    const columnHeader = this.page.getByRole('columnheader', { name: new RegExp(columnName, 'i') });    const sortButton = columnHeader.getByRole('button');    await sortButton.click();  }  async filterTableColumn(columnName: string, value: string) {    await this.showTableFilters();    const filterInput = this.page.getByPlaceholder(new RegExp(`Filter ${columnName.toLowerCase()}`, 'i'));    await filterInput.fill(value);  }  async isExportAvailable(): Promise<boolean> {    const exportButton = this.page.getByRole('button', { name: /Export to CSV/i });    return await exportButton.isEnabled();  }  async openExportDialog() {    const exportButton = this.page.getByRole('button', { name: /Export to CSV/i });    await expect(exportButton).toBeEnabled();    await exportButton.click();  }  async waitForStableState() {    await this.page.waitForTimeout(2000);    await this.page.waitForLoadState('networkidle');  }  async takeDebugScreenshot(name: string) {    await this.page.screenshot({       path: `tests/screenshots/${name}.png`,      fullPage: true     });  }  async isInViewport(selector: string): Promise<boolean> {    return await this.page.evaluate((sel) => {      const element = document.querySelector(sel);      if (!element) return false;      const rect = element.getBoundingClientRect();      return (        rect.top >= 0 &&        rect.left >= 0 &&        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&        rect.right <= (window.innerWidth || document.documentElement.clientWidth)      );    }, selector);  }  async addCategoryFilter(categoryName: string): Promise<boolean> {    const categoryButton = this.page.getByRole('button', { name: categoryName }).first();    try {      await categoryButton.waitFor({ state: 'visible', timeout: 2000 });      await categoryButton.click();      await this.page.waitForTimeout(2000);      return true;    } catch (error) {      return false;    }  }  async openAdvancedFilters(): Promise<boolean> {    const advancedButton = this.page.getByRole('button', { name: /Advanced Filters/i });    try {      await advancedButton.waitFor({ state: 'visible', timeout: 2000 });      await advancedButton.click();      await this.page.waitForTimeout(1000);      return true;    } catch (error) {      return false;    }  }  async closeAdvancedFilters(): Promise<boolean> {    const advancedButton = this.page.getByRole('button', { name: /Advanced Filters/i });    try {      const isExpanded = await advancedButton.getAttribute('aria-expanded');      if (isExpanded === 'true') {        await advancedButton.click();        await this.page.waitForTimeout(1000);      }      return true;    } catch (error) {      return false;    }  }  async saveQuery(queryName: string): Promise<boolean> {    try {      const saveButton = this.page.getByRole('button', { name: /Save Query/i });      await saveButton.click();      const dialog = this.page.getByRole('dialog');      await dialog.waitFor({ state: 'visible', timeout: 2000 });      const nameInput = dialog.getByRole('textbox', { name: /Query name/i });      await nameInput.fill(queryName);      const saveQueryButton = dialog.getByRole('button', { name: /Save/i });      await saveQueryButton.click();      await dialog.waitFor({ state: 'hidden', timeout: 2000 });      return true;    } catch (error) {      return false;    }  }  async loadQuery(queryName: string): Promise<boolean> {    try {      const loadButton = this.page.getByRole('button', { name: /Load Query/i });      await loadButton.click();      const queryItem = this.page.getByText(queryName);      await queryItem.waitFor({ state: 'visible', timeout: 2000 });      await queryItem.click();      await this.page.waitForTimeout(1000);      return true;    } catch (error) {      return false;    }  }  async getSearchResultsCount(): Promise<number> {    try {      const resultsText = await this.page.getByText(/(\d+)\s+companies found/).textContent();      if (resultsText) {        const match = resultsText.match(/(\d+)\s+companies found/);        return match ? parseInt(match[1]) : 0;      }      return 0;    } catch (error) {      return 0;    }  }  async setFilterMode(mode: 'Contains Any' | 'Contains All' | 'Contains None'): Promise<boolean> {    try {      const checkbox = this.page.getByRole('checkbox', { name: mode });      await checkbox.waitFor({ state: 'visible', timeout: 2000 });      await checkbox.click();      await this.page.waitForTimeout(1000);      return true;    } catch (error) {      return false;    }  }  async waitForSearchToComplete(): Promise<boolean> {    try {      await Promise.race([        this.page.getByText(/companies found/).waitFor({ timeout: 10000 }),        this.page.getByText('No companies found').waitFor({ timeout: 10000 }),        this.page.getByRole('table').waitFor({ timeout: 10000 })      ]);      return true;    } catch (error) {      return false;    }  }}export function createTestHelpers(page: Page): TestHelpers {  return new TestHelpers(page);}